#!/usr/bin/env python3
"""
Classroom manager for the persistent PortaCode workspace.

It can bootstrap a brand-new class or manage an existing one by adding/removing
student containers and regenerating docker-compose.yaml on demand.
"""

from __future__ import annotations

import json
import os
import re
import shutil
import subprocess
import sys
import textwrap
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional

if sys.version_info < (3, 10):
    sys.stderr.write(
        "manage_classroom.py requires Python 3.10 or newer.\n"
        "Please rerun with `python3 manage_classroom.py`.\n"
    )
    sys.exit(1)

BASE_DIR = Path(__file__).resolve().parent
STUDENTS_DIR = BASE_DIR / "students"
COMPOSE_FILE = BASE_DIR / "docker-compose.yaml"
ENV_FILE = BASE_DIR / ".env"
STATE_FILE = BASE_DIR / "classroom_state.json"

DEFAULT_GATEWAY = "wss://portacode.com/gateway"
DEFAULT_PREFIX = "Workshop-Device"


@dataclass
class Student:
    index: int
    slug: str
    device_name: str
    service_name: str
    pairing_code: str
    host_path: Path


def prompt(text: str, *, default: Optional[str] = None, required: bool = False) -> str:
    while True:
        suffix = f" [{default}]" if default else ""
        value = input(f"{text}{suffix}: ").strip()
        if not value and default:
            value = default
        if required and not value:
            print("Please provide a value.")
            continue
        return value


def prompt_int(text: str, *, default: Optional[int] = None, minimum: int = 1) -> int:
    while True:
        suffix = f" [{default}]" if default is not None else ""
        raw = input(f"{text}{suffix}: ").strip()
        if not raw and default is not None:
            return default
        try:
            value = int(raw)
        except ValueError:
            print("Enter a whole number.")
            continue
        if value < minimum:
            print(f"Value must be >= {minimum}.")
            continue
        return value


def prompt_yes_no(text: str, *, default: bool = False) -> bool:
    hint = "Y/n" if default else "y/N"
    while True:
        raw = input(f"{text} ({hint}): ").strip().lower()
        if not raw:
            return default
        if raw in {"y", "yes"}:
            return True
        if raw in {"n", "no"}:
            return False
        print("Please answer y or n.")


def slugify(value: str) -> str:
    cleaned = re.sub(r"[^a-zA-Z0-9]+", "-", value).strip("-")
    slug = cleaned.lower()
    return slug or "device"


def split_prefix(prefix: str) -> tuple[str, int]:
    trimmed = prefix.strip()
    match = re.search(r"(\d+)$", trimmed)
    if match:
        width = len(match.group(1))
        base = trimmed[: match.start()].rstrip("-_ ")
        return (base or "device", width)
    return (trimmed or "device", 2)


def ensure_docker_compose() -> None:
    try:
        subprocess.run(
            ["docker", "compose", "version"],
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
    except subprocess.CalledProcessError as exc:
        raise SystemExit(
            "Docker Compose plugin is required. Make sure `docker compose` works "
            "before running this script."
        ) from exc


def create_student_dirs(students: List[Student]) -> None:
    for student in students:
        workspace_dir = student.host_path
        root_dir = workspace_dir.parent
        portacode_dir = root_dir / ".portacode"
        logs_dir = root_dir / "logs"
        local_dir = root_dir / ".local"
        local_share_dir = local_dir / "share"
        local_share_portacode_dir = local_share_dir / "portacode"
        for path, mode in [
            (workspace_dir, 0o777),
            (portacode_dir, 0o700),
            (logs_dir, 0o755),
            (local_dir, 0o700),
            (local_share_dir, 0o700),
            (local_share_portacode_dir, 0o700),
        ]:
            path.mkdir(parents=True, exist_ok=True)
            os.chmod(path, mode)


def write_env_file(gateway: str) -> None:
    content = textwrap.dedent(
        f"""\
        # Generated by manage_classroom.py
        PORTACODE_GATEWAY={gateway}
        """
    )
    ENV_FILE.write_text(content)


def build_compose_yaml(students: List[Student]) -> str:
    lines = ["services:"]
    for student in students:
        host_rel = os.path.relpath(student.host_path, BASE_DIR).replace("\\", "/")
        root_rel = os.path.relpath(student.host_path.parent, BASE_DIR).replace("\\", "/")
        portacode_rel = f"{root_rel}/.portacode"
        logs_rel = f"{root_rel}/logs"
        local_share_portacode_rel = f"{root_rel}/.local/share/portacode"
        lines.extend(
            [
                f"  {student.service_name}:",
                "    build:",
                "      context: .",
                "    image: portacode/workshop-device-persistent:latest",
                f"    hostname: {student.service_name}",
                "    environment:",
                "      PORTACODE_GATEWAY: ${PORTACODE_GATEWAY}",
                f"      PORTACODE_PAIRING_CODE: {json.dumps(student.pairing_code)}",
                f"      PORTACODE_DEVICE_NAME: {json.dumps(student.device_name)}",
                "    volumes:",
                f"      - ./{host_rel}:/home/student/workspace",
                f"      - ./{portacode_rel}:/home/student/.portacode",
                f"      - ./{logs_rel}:/home/student/logs",
                f"      - ./{local_share_portacode_rel}:/home/student/.local/share/portacode",
                "    restart: unless-stopped",
            ]
        )
    return "\n".join(lines) + "\n"


def run_compose_up(detached: bool = True) -> None:
    cmd = ["docker", "compose", "up"]
    if detached:
        cmd.append("-d")
    cmd.append("--remove-orphans")
    try:
        subprocess.run(cmd, check=True, cwd=BASE_DIR)
    except subprocess.CalledProcessError as exc:
        raise SystemExit(
            "docker compose up failed. Fix the error above and rerun this script."
        ) from exc


def serialize_student(student: Student) -> Dict[str, str]:
    return {
        "index": student.index,
        "slug": student.slug,
        "device_name": student.device_name,
        "service_name": student.service_name,
        "pairing_code": student.pairing_code,
        "workspace": os.path.relpath(student.host_path, BASE_DIR),
    }


def deserialize_student(data: Dict[str, str]) -> Student:
    return Student(
        index=int(data["index"]),
        slug=data["slug"],
        device_name=data["device_name"],
        service_name=data["service_name"],
        pairing_code=data["pairing_code"],
        host_path=BASE_DIR / data["workspace"],
    )


def load_state() -> Optional[Dict]:
    if not STATE_FILE.exists():
        return None
    data = json.loads(STATE_FILE.read_text())
    # Backward compatibility with the earlier format.
    if "base_label" not in data or "number_width" not in data:
        base_label, number_width = split_prefix(data.get("device_prefix", DEFAULT_PREFIX))
        data["base_label"] = base_label
        data["number_width"] = number_width
    if "next_index" not in data:
        indices = [
            int(item.get("index")) if "index" in item else _infer_index(item, data)
            for item in data.get("students", [])
        ]
        data["next_index"] = max(indices, default=0) + 1
    if "pairing_code" not in data:
        data["pairing_code"] = ""
    # Ensure every student has an index and workspace field.
    for item in data.get("students", []):
        slug = item.get("slug", "")
        slug_match = re.search(r"(\d+)$", slug)
        if slug_match:
            item["index"] = int(slug_match.group(1))
        elif "index" not in item:
            item["index"] = _infer_index(item, data)
        if "workspace" not in item:
            item["workspace"] = item.get("host_path") or item["slug"]
        if not item.get("slug"):
            slug_candidate = item.get("service_name") or slugify(item.get("device_name", ""))
            if not slug_candidate:
                workspace = item.get("workspace", "")
                try:
                    slug_candidate = Path(workspace).parts[-2]
                except IndexError:
                    slug_candidate = "device"
            item["slug"] = slug_candidate
        if not item.get("pairing_code"):
            item["pairing_code"] = data.get("pairing_code") or ""
    return data


def _infer_index(student: Dict[str, str], state: Dict) -> int:
    slug = student.get("slug", "")
    match = re.search(r"(\d+)$", slug)
    if match:
        return int(match.group(1))
    return len(state.get("students", [])) + 1


def save_state(state: Dict) -> None:
    state_copy = json.loads(json.dumps(state))
    students = [dict(item) for item in state_copy.get("students", [])]
    students.sort(key=lambda item: int(item["index"]))
    state_copy["students"] = students
    STATE_FILE.write_text(json.dumps(state_copy, indent=2))


def build_student(
    *,
    base_label: str,
    slug_base: str,
    number_width: int,
    index: int,
    pairing_code: str,
) -> Student:
    number = f"{index:0{number_width}d}"
    slug = f"{slug_base}-{number}"
    device_name = f"{base_label}-{number}" if base_label else number
    return Student(
        index=index,
        slug=slug,
        device_name=device_name,
        service_name=slug,
        pairing_code=pairing_code,
        host_path=STUDENTS_DIR / slug / "workspace",
    )


def state_to_students(state: Dict) -> List[Student]:
    return [deserialize_student(item) for item in state.get("students", [])]


def regenerate_files(state: Dict) -> List[Student]:
    students = state_to_students(state)
    create_student_dirs(students)
    write_env_file(state["gateway"])
    COMPOSE_FILE.write_text(build_compose_yaml(students))
    save_state(state)
    return students


def initial_setup() -> Dict:
    print(
        textwrap.dedent(
            """
            === PortaCode Persistent Workspace (first-time setup) ===
            Answer a few questions and we will provision every student container.
            """
        ).strip()
    )
    pairing_code = prompt("PortaCode pairing code", required=True)
    device_prefix = prompt(
        "Device name prefix", default=DEFAULT_PREFIX, required=True
    )
    num_students = prompt_int("Number of student containers", default=3, minimum=1)
    gateway = prompt("PortaCode gateway URL", default=DEFAULT_GATEWAY, required=True)

    base_label, number_width = split_prefix(device_prefix)
    slug_base = slugify(base_label)

    students: List[Student] = []
    for idx in range(1, num_students + 1):
        students.append(
            build_student(
                base_label=base_label,
                slug_base=slug_base,
                number_width=number_width,
                index=idx,
                pairing_code=pairing_code,
            )
        )

    state = {
        "pairing_code": pairing_code,
        "device_prefix": device_prefix,
        "base_label": base_label,
        "number_width": number_width,
        "gateway": gateway,
        "next_index": num_students + 1,
        "students": [serialize_student(student) for student in students],
    }
    regenerate_files(state)
    run_compose_up()
    print("\nAll containers are starting! Use `docker compose ps` to check status.\n")
    return state


def add_students(state: Dict) -> None:
    count = prompt_int("How many new students to add?", default=1, minimum=1)
    new_pairing_code = prompt(
        "Enter the new PortaCode pairing code for these students", required=True
    )
    state["pairing_code"] = new_pairing_code
    slug_base = slugify(state["base_label"])
    new_students: List[Student] = []
    for _ in range(count):
        idx = state["next_index"]
        state["next_index"] += 1
        student = build_student(
            base_label=state["base_label"],
            slug_base=slug_base,
            number_width=state["number_width"],
            index=idx,
            pairing_code=new_pairing_code,
        )
        state["students"].append(serialize_student(student))
        new_students.append(student)
    print(f"Added {len(new_students)} student(s). Regenerating files...")
    regenerate_files(state)
    run_compose_up()
    print("New containers are launching now.")


def remove_students(state: Dict) -> None:
    students = state_to_students(state)
    if not students:
        print("There are no students to remove.")
        return

    print("\nCurrent students:")
    for student in students:
        print(f"  [{student.index}] {student.device_name} ({student.slug})")

    raw = input(
        "\nEnter the numeric IDs to remove (comma-separated), or press Enter to cancel: "
    ).strip()
    if not raw:
        print("No changes made.")
        return

    try:
        ids = {int(value.strip()) for value in raw.split(",")}
    except ValueError:
        print("Invalid input. Please enter numeric IDs.")
        return

    remaining = []
    removed = []
    for student_dict in state["students"]:
        if int(student_dict["index"]) in ids:
            removed.append(deserialize_student(student_dict))
        else:
            remaining.append(student_dict)

    if not removed:
        print("No matching students found.")
        return

    delete_data = prompt_yes_no("Delete the workspace directories from disk?", default=False)
    if delete_data:
        for student in removed:
            path = student.host_path.parent
            if path.exists():
                print(f"  removing {path}")
                shutil.rmtree(path, ignore_errors=True)

    state["students"] = remaining
    print(f"Removed {len(removed)} student(s). Regenerating files...")
    regenerate_files(state)
    run_compose_up()
    print("Compose stack updated (removed containers will stop).")


def menu_loop(state: Dict) -> None:
    while True:
        print(
            textwrap.dedent(
                """
                === PortaCode Classroom Manager ===
                1) Add students
                2) Remove students
                3) Rebuild docker-compose (no changes)
                4) Exit
                """
            ).strip()
        )
        choice = input("Select an option: ").strip()
        if choice == "1":
            add_students(state)
        elif choice == "2":
            remove_students(state)
        elif choice == "3":
            regenerate_files(state)
            run_compose_up()
            print("Compose stack refreshed.")
        elif choice == "4":
            print("Goodbye!")
            break
        else:
            print("Invalid choice. Please enter 1-4.")


def main() -> None:
    ensure_docker_compose()
    state = load_state()
    if state is None:
        state = initial_setup()
        print("Re-run manage_classroom.py anytime to add or remove students.\n")
    else:
        students = state_to_students(state)
        print(
            f"Loaded existing classroom with {len(students)} student(s). "
            "Use the menu below to make changes."
        )
        menu_loop(state)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted by user.")
